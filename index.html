<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title></title>
<style>
body {
	margin: 2%;
}
#board {
	width: 100%;
	table-layout: fixed; /* don't resize table on text swap */
	border-collapse: collapse;
	text-align: center;
	
	color: #555;
	font-family: Helvetica;
	font-size: 1.5em;
	font-weight: bold;

	background-color: #fdf9f3;
}
#board td {
	border: 2px #ddd solid;
	padding: 2.5%;
}
</style>
</head>
<body> 
<h1>stratego</h1>
<table id="board"></table>

<script>
// https://css-tricks.com/dangers-stopping-event-propagation/
// https://developer.mozilla.org/en-US/docs/Web/API/Event/Comparison_of_Event_Targets
// https://stijndewitt.com/2014/01/26/enums-in-javascript/
// https://davidwalsh.name/event-delegate
// https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment

// http://www.robert-drummond.com/2015/04/21/event-driven-programming-finite-state-machines-and-nodejs/

function Board() {
	this.empty = null;
	this.board = [
		[this.empty, new Piece('3', Player.ONE), new Piece('3', Player.TWO), this.empty],
		[this.empty, this.empty, this.empty, new Piece('4', Player.TWO)],
		[this.empty, this.empty, this.empty, this.empty],
		[this.empty, new Piece('2', Player.TWO), this.empty, this.empty]
	];
	this.numRows = this.board.length;
	this.numCols = this.board[0].length;

	this.getCell = function (row, col) {
		return this.board[row][col];
	};

	// this.cellEmpty = function (row, col) {
	// 	return this.board[row][col] === this.empty;
	// };

	this.cellEmpty = function (cell) {
		return cell === this.empty;
	}
}

function Piece(rank, player) {
	this.rank = rank;
	this.player = player;
	this.color = (player === Player.ONE) ? "red" : "blue";
}

function View() {
	this.empty = String.fromCharCode(160);

	this.getBoard = function() {
		return document.getElementById("board");
	}

	this.getCellId = function (row, col) {
		return ["a", row, col].join("-"); // must start with letter
	}

	this.getRowCol = function (cellId) {
		var parts = cellId.split("-");
		var row = parseInt(parts[1]), col = parseInt(parts[2]);
		return {row: row, col: col}
	}

	// this.getCell = function (row, col) {
	// 	var id = this.getCellId(row, col)
	// 	return document.getElementById(id);
	// }

	this.cellEmpty = function (cell) {
		return cell.textContent === this.empty;
	}

	this.cellsEdgeAdjacent = function (c1id, c2id) {
		var c1 = this.getRowCol(c1id), c2 = this.getRowCol(c2id);
		var adjacent = (
			(c1.row >= c2.row - 1 && c1.row <= c2.row + 1) && 
			(c1.col >= c2.col - 1 && c1.col <= c2.col + 1));
		var diagonal = (c1.row !== c2.row && c1.col !== c2.col);
		return (adjacent && !diagonal);
	}
}

var ClickState = {
	NONE: 0,
	SELECTED: 1,
};

// var PieceState = {
// 	MOVE: 0,
// 	BATTLE: 1,
// }

var Player = {
	ONE: 0,
	TWO: 1,
}


function Game(View, Board) {
	var self = this;
	this.previousSelectedCell = null;
	this.View = View;
	this.Board = Board;
	this.state = ClickState.NONE;
	this.currentPlayer = Player.ONE;

	this.start = function() {
		this.initializeBoard();
		View.getBoard().addEventListener("click", this.handleClick);

		// clear non-board clicks
		document.addEventListener("click", function (ev) { 
			var boardClicked = ev.defaultPrevented;
			if (!boardClicked) {
				console.log("cleared");
				this.previousSelectedCell = null;
			}
		});
	}

	this.initializeBoard = function() {
		var board = document.createDocumentFragment("")
		for (var i = 0; i < this.Board.numRows; i++) {
			var row = document.createElement("tr");

			for (var j = 0; j < this.Board.numCols; j++) {
				var piece = this.Board.getCell(i, j);
				var cell = document.createElement("td");

				if (this.Board.cellEmpty(piece)) {
					cell.textContent = View.empty;
				} else {
					cell.textContent = this.Board.getCell(i, j).rank;
					cell.style.color = piece.color;
				}

				cell.id = View.getCellId(i, j);
				row.appendChild(cell);
			}
			board.appendChild(row);
		}
		this.View.getBoard().appendChild(board);
	}

	this.handleClick = function (ev) {
		ev.preventDefault(); // flag event so document won't handle it

		var selectedCell = ev.target;
		var pos = self.View.getRowCol(selectedCell.id);
		var selectedPiece = self.Board.getCell(pos.row, pos.col);
		var selectedEmpty = self.Board.cellEmpty(selectedPiece);
		var selfSelected = (selectedEmpty) ? 
			false : selectedPiece.player === self.currentPlayer;
		var adjacent = (self.previousSelectedCell) ? 
			self.View.cellsEdgeAdjacent(self.previousSelectedCell.id, 
				selectedCell.id) : false;

		// console.log("state", self.state, "pos", pos.row, pos.col, "piece", selectedPiece, "empty", selectedEmpty, "own", selfSelected, "adjacent", adjacent);

		switch (self.state) {
			case ClickState.NONE:
				// if valid piece selection, store
				if (!selectedEmpty && 
					selectedPiece.player === self.currentPlayer) {
					self.previousSelectedCell = selectedCell;
					self.state = ClickState.SELECTED;
				}
				break;
			case ClickState.SELECTED:
				if (adjacent) {
					// move
					if (selectedEmpty) {
						console.log("moving")
					}
					// battle 
					else if (selectedPiece.player !== self.currentPlayer) {
						console.log("battle");
					}
				}
				self.previousSelectedCell = null;
				self.state = ClickState.NONE;
				break;
			default:
				break;
		}
	}
};


var game = new Game(new View(), new Board());
game.start();
</script>

</body>
</html>













